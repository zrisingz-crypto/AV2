# AV2 真实解码模块集成计划

## 概述

本文档说明如何将真实的RTL解码模块集成到现有的AV2 tile decoder中，以实现完整的真实解码功能。

## 已实现的模块

### 1. av2_intra_prediction_real.v
**功能**：真实的帧内预测模块
**支持模式**：
- DC prediction (平均参考像素)
- V prediction (垂直复制)
- H prediction (水平复制)
- PAETH prediction (选择最接近参考像素)
- SMOOTH prediction (平滑插值)
- SMOOTH_V prediction (垂直平滑)
- SMOOTH_H prediction (水平平滑)
- ANGULAR prediction (角度预测，简化版)

**接口**：
```verilog
module av2_intra_prediction_real #(
    parameter MAX_BLOCK_SIZE = 64,
    parameter BIT_DEPTH = 10
)(
    input  wire clk, rst_n,
    input  wire [9:0] ref_top [0:MAX_BLOCK_SIZE-1],
    input  wire [9:0] ref_left [0:MAX_BLOCK_SIZE-1],
    input  wire [9:0] ref_top_left,
    input  wire [6:0] intra_mode,
    input  wire [5:0] block_width,
    input  wire [5:0] block_height,
    input  wire start,
    output reg  [9:0] pred_pixels [0:4095],
    output reg valid,
    input  wire ready
);
```

### 2. av2_entropy_decoder_real.v
**功能**：基于range coder的真实熵解码器
**算法**：基于软件实现中的od_ec_dec（entdec.c）

**特性**：
- 支持CDF（累积分布函数）解码
- 支持上下文模型更新
- 支持bypass模式解码
- 精确的range normalization

**接口**：
```verilog
module av2_entropy_decoder_real #(
    parameter DATA_WIDTH = 128,
    parameter WINDOW_SIZE = 32,
    parameter CDF_PROB_TOP = 32768
)(
    input  wire clk, rst_n,
    input  wire [DATA_WIDTH-1:0] bitstream_data,
    input  wire bitstream_valid,
    output reg bitstream_ready,
    input  wire [15:0] context_idx,
    input  wire [15:0] context_prob,
    output reg [15:0] context_idx_out,
    output reg context_update_en,
    output reg [15:0] context_update_idx,
    output reg context_update_bit,
    input  wire reset_contexts,
    output reg [15:0] symbol,
    output reg symbol_valid,
    input  wire symbol_ready,
    input  wire start,
    output wire done
);
```

### 3. av2_inverse_transform_real.v
**功能**：真实的逆变换模块
**支持变换**：
- IDCT (逆离散余弦变换)
- IDST (逆离散正弦变换)
- 混合变换 (DCT+ADST等)

**特性**：
- 支持4x4到64x64的变换尺寸
- 2D变换（先列后行）
- 精确的scaling和rounding
- 支持clipping到有效范围

**接口**：
```verilog
module av2_inverse_transform_real #(
    parameter MAX_TX_SIZE = 64,
    parameter BIT_DEPTH = 10
)(
    input  wire clk, rst_n,
    input  wire signed [15:0] coeffs [0:4095],
    input  wire [15:0] num_coeffs,
    input  wire [5:0] tx_width,
    input  wire [5:0] tx_height,
    input  wire [3:0] tx_type,
    input  wire start,
    output reg signed [15:0] pixels [0:4095],
    output reg valid,
    input  wire ready,
    output wire done
);
```

## 集成步骤

### 步骤1：修改av2_tile_decoder_complete.v

**1.1 替换模块实例化**

将stub模块替换为真实模块：

```verilog
// 替换熵解码器
av2_entropy_decoder_real #(
    .DATA_WIDTH(128)
) u_entropy_decoder (
    .clk              (clk),
    .rst_n            (rst_n),
    .bitstream_data   (tile_data),
    .bitstream_valid  (tile_valid && (state == ENTROPY_DECODE)),
    .bitstream_ready  (tile_ready),
    .context_idx      (context_idx),
    .context_prob     (context_prob),
    .context_idx_out  (context_idx_out),
    .context_update_en (context_update_en),
    .context_update_idx(context_update_idx),
    .context_update_bit(context_update_bit),
    .reset_contexts   (state == IDLE && start),
    .symbol           (entropy_symbol),
    .symbol_valid     (entropy_valid),
    .symbol_ready     (entropy_ready),
    .start            (state == ENTROPY_DECODE),
    .done             (entropy_done)
);

// 替换帧内预测器
av2_intra_prediction_real #(
    .MAX_BLOCK_SIZE(64),
    .BIT_DEPTH(10)
) u_intra_prediction (
    .clk              (clk),
    .rst_n            (rst_n),
    .ref_top          (ref_top),
    .ref_left         (ref_left),
    .ref_top_left     (ref_top_left),
    .intra_mode       (intra_mode),
    .block_width      (block_width),
    .block_height     (block_height),
    .start            (state == PREDICTION && frame_type == 2'd0),
    .pred_pixels      (intra_pred_pixels),
    .valid            (intra_pred_valid),
    .ready            (intra_pred_ready)
);

// 替换逆变换器
av2_inverse_transform_real #(
    .MAX_TX_SIZE(64),
    .BIT_DEPTH(10)
) u_inverse_transform (
    .clk              (clk),
    .rst_n            (rst_n),
    .coeffs           (decoded_coeffs),
    .num_coeffs       (num_coeffs),
    .tx_width         (block_width),
    .tx_height        (block_height),
    .tx_type          (tx_type),
    .start            (state == INVERSE_TX),
    .pixel_out        (residual_pixels),
    .valid            (itx_valid),
    .ready            (itx_ready)
);
```

**1.2 添加缺失的信号**

在tile decoder中添加真实模块需要的信号：

```verilog
// 熵解码器输出
wire [15:0] entropy_symbol;
wire        entropy_valid;
reg         entropy_ready;
wire        entropy_done;

// 上下文模型接口
wire [15:0] context_idx_out;
wire        context_update_en;
wire [15:0] context_update_idx;
wire        context_update_bit;

// 帧内预测接口
wire [9:0]  intra_pred_pixels [0:4095];
wire        intra_pred_valid;
reg         intra_pred_ready;

// 逆变换接口
wire signed [15:0] residual_pixels [0:4095];
wire        itx_valid;
reg         itx_ready;
```

### 步骤2：实现系数解码器

需要实现真实的系数解码器（av2_coeff_decoder_real.v），支持：
- Token解析（从entropy decoder获取符号）
- Run-length解码（跳过零系数）
- EOB（End of Block）处理
- 系数符号解码
- 系数值解码

### 步骤3：修改解码流水线

**3.1 熵解码阶段**

```verilog
ENTROPY_DECODE: begin
    // 等待熵解码器完成
    if (entropy_done) begin
        state_next = INVERSE_TX;
    end
end
```

**3.2 逆变换阶段**

```verilog
INVERSE_TX: begin
    // 启动逆变换
    itx_ready <= 1'b1;
    if (itx_valid) begin
        state_next = PREDICTION;
    end
end
```

**3.3 帧内预测阶段**

```verilog
PREDICTION: begin
    // 等待预测完成
    if (intra_pred_valid) begin
        // 将预测像素写入缓冲
        for (i = 0; i < 4096; i = i + 1) begin
            pred_buffer[i] <= intra_pred_pixels[i];
        end
        state_next = RECONSTRUCTION;
    end
end
```

**3.4 重建阶段**

```verilog
RECONSTRUCTION: begin
    // 重建：预测 + 残差
    for (i = 0; i < block_width * block_height; i = i + 1) begin
        // 临时计算
        reg [10:0] temp_recon;
        temp_recon = pred_buffer[i] + residual_pixels[i];
        
        // Clipping
        if (temp_recon > 10'd1023) begin
            recon_frame[i] <= 10'd1023;
        end else if (temp_recon < 10'd0) begin
            recon_frame[i] <= 10'd0;
        end else begin
            recon_frame[i] <= temp_recon[9:0];
        end
    end
    state_next = WRITE_OUTPUT;
end
```

### 步骤4：参考像素管理

需要实现参考像素的读取和更新：
- 从recon_frame读取已解码的块作为参考
- 更新ref_top和ref_left数组
- 处理边界条件

```verilog
// 在解码新块之前更新参考像素
if (state == PARSE_SB_HEADER) begin
    // 更新上方参考像素
    if (block_y_coord > 0) begin
        for (i = 0; i < block_width; i = i + 1) begin
            ref_top[i] <= recon_frame[(block_y_coord - 1) * frame_width + block_x_coord + i];
        end
    end
    
    // 更新左侧参考像素
    if (block_x_coord > 0) begin
        for (j = 0; j < block_height; j = j + 1) begin
            ref_left[j] <= recon_frame[(block_y_coord + j) * frame_width + block_x_coord - 1];
        end
    end
    
    // 更新左上角参考像素
    if (block_x_coord > 0 && block_y_coord > 0) begin
        ref_top_left <= recon_frame[(block_y_coord - 1) * frame_width + block_x_coord - 1];
    end
end
```

### 步骤5：测试和验证

**5.1 单元测试**
- 测试熵解码器独立功能
- 测试帧内预测各种模式
- 测试逆变换各种尺寸和类型

**5.2 集成测试**
- 测试完整解码流程
- 与软件解码器输出对比
- 验证YUV输出正确性

**5.3 性能测试**
- 测量解码延迟
- 验证throughput
- 检查资源使用

## 待实现功能

1. **系数解码器**（av2_coeff_decoder_real.v）
   - Token解析
   - Run-length解码
   - EOB处理

2. **运动矢量解码器**（av2_mv_decoder_real.v）
   - MV解码
   - 参考帧索引
   - 双向预测

3. **运动补偿**（av2_motion_compensation_real.v）
   - 插值滤波器
   - 亚像素运动补偿
   - 参考帧读取

4. **环路滤波器**
   - 去块滤波器（真实实现）
   - CDEF滤波器（真实实现）
   - Loop Restoration（真实实现）

## 注意事项

1. **时序约束**：确保真实模块满足时钟频率要求
2. **流水线深度**：平衡吞吐量和延迟
3. **资源使用**：优化BRAM和DSP使用
4. **仿真验证**：充分测试边界条件

## 参考资料

- 软件实现：avm_dsp/entdec.c, avm_dsp/intrapred.c, avm_dsp/fwd_txfm.c
- AV2规范：https://aomediacodec.github.io/av1-spec/
- AV1/AV2解码流程文档